## 重写 forEach 方法（支持对象遍历）

需要考虑的点：

- Symbol 无法用 `for...in...` 遍历的，可以使用 `Object.getOwnPropertySymbols()` 获取，之后结合 for 循环或 `Object.keys()` 使用即可

```js
function each(obj, callback) {
  let keys = Object.keys(obj),
    key = null,
    value = null,
    i = 0,
    len = 0
  if (typeof Symbol !== 'undefined') {
    // 支持Symbol
    keys = keys.concat(Object.getOwnPropertySymbols(obj))
  }
  len = keys.length
  if (typeof callback !== 'function') callback = function () {}
  for (; i < len; i++) {
    key = keys[i]
    value = obj[key]
    callback(value, key)
  }
}
```

## 重写 new

new 步骤：

1. 创建Ctor的一个实例对象

   `实例.__proto__ = Ctor.prototype`

2. 把构造函数当做普通函数执行（让方法中的this->实例对象）

3. 确认方法的返回值（如果没有返回值或者返回的是原始值，我们让其默认返回实例对象即可）

需要考虑的点：

- Symbol、BigInt 不能被 new

- 箭头函数不能被 new

  [https://blog.csdn.net/weixin_42798473/article/details/105319353](https://blog.csdn.net/weixin_42798473/article/details/105319353)

```js
/*
Ctor -> constructor缩写（构造函数）
params -> 后期给Ctor传递的所有实参信息
*/
function _new(Ctor, ...params) {
  let obj,
    result,
    proto = Ctor.prototype
  // 校验规则
  if (Ctor === Symbol || Ctor === BigInt || typeof Ctor !== 'function' || !proto)
    throw new TypeError(`${Ctor} is not a constructor`)
  obj = Object.create(Ctor.prototype)
  result = Ctor.call(obj, ...params)
  if (/^(object|function)$/.test(typeof result)) return result
  return obj
}
```

